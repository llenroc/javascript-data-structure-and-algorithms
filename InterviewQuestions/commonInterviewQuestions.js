/**
 
~~~~~~~~Stack and Queue questions ~~~~~~

Q1. Use an array to implement 3 stacks.

Q2. Implement a getMin() or getMax() method on your stack.

Q3. Create a queue using 2 stacks.

Q4. Sort a stack with the min values in order, on top. You can use another stack as a buffer.

Q5. Write a function that returns true if a string of brackets is valid/balanced.

~~~~~~~~~~ Linked List ~~~~~~~~~~~~~ 

Q6. Delete the following:-
  1 - a node in the middle of the linked list 
  2 - a node with only a variable pointing at that node
  3 - a duplicate

Q7. Partition a linked list around a value.

Q8. Write a function for reversing a linked list.
    Can you do it in-place?

Q9. Check if a linked list contains a cycle.

Q10. Find the kth to the last node.


*** Additional Exercises:

Implement a circularly linked list:
https://en.wikipedia.org/wiki/Linked_list#Circularly_linked_list

Reimplement stack and queue data structures using linked lists.


~~~~~~~~~~ Hash Table ~~~~~~~~~~~~~ 

Q1. Count the number of occurrences of all characters or words in a body of text or string.

Q2. Delete duplicates in a list.

Q3. Find a unique value in a list.

Q4. Find if two integers in a list add up to k

Q5. Resize the hash table:
- if the count becomes greater than 75% of the table size, double the table size and redistribute the key/value pairs
- if the count becomes less than 25% of the table size, cut the table size in half and redistribute the key/value pairs

*** Exercises:
  
  1. Implement a hash table with a binary search tree.
  
  2. Given two arrays with values, return the values that are present in both. Do this in linear time.
  
  3. Implement a hash table using linked lists for collision-handling. Why might this be preferable to using arrays.


~~~~~~~~~~ Array ~~~~~~~~~~~~~ 

Q1. Rotate a matrix, string, or an array.

Q2. Given an m x n boolean matrix, if an element is 0, set its entire row and column to 0.

Q3. Search for a value.

Q4. Write a function encodes a string by turning all spaces into `%20`.

Q5. Merge two sorted lists into one list.


~~~~~~~~~~ Tree ~~~~~~~~~~~~~ 

Q1. Tries 

Q2. 

~~~~~~~~~~ Common tasks for BFS / DFS ~~~~~~~~~~~~~ 
Q1. Logging or validating the contents of each edge and/or vertex.

Q2. Copying a graph, or converting between adjacency matrix or list.

Q3. Counting the number of edges and/or vertices.

Q4. Identifying the connected components 

Q5. Finding paths or cycles between two vertices


~~~~~~~~~~ Graphs ~~~~~~~~~~~~~ 

Q1. Directed, Undirected 

Q2. Weighted, Unweighted

Q3. Self loop

Q4. Sparse, Dense

Q5. Cyclic, Acyclic 




~~~~~~~~~~ Searching ~~~~~~~~~~~~~ 

Linear search -> O(n)
Binary search -> O(Log(n))
  - Always for sorted list ( TC for sorting nlog(n))
  - Psudo code 
      firstIndex = 0;
      lastIndex = 5;
      mid = Math.floor((lastIndex - firstIndex) / 2 ) = 2 


~~~~~~~~~~ Binary serach Tree ~~~~~~~~~~~~~ 

Q1. Balanced, Unbalanced 

Q2. height of the tree. 

Q3. 



 */

